​총 10개의 알파벳만이 문자열을 구성하는데 사용됨 (a~j) 각 알파벳의 출현 빈도수가 홀수인지 짝수인지를 비트 마스크로 표현 가능 ex) "feffaec" -> 1000101 (짝수면 0, 홀수면 1)

모든 문자열이 짝수번 출현한다면 비트 마스크가 0이 될 것.

비트 마스크가 0이 되는 부분 문자열이 몇 개인지 알아야 함. -> 부분 문자열 [a, b]의 비트 마스크는 부분 문자열 [0, b]의 비트 마스크에서 부분 문자열 [0, a - 1]의 비트 마스크를 뺀 값 -> 부분 문자열 [a, b]의 비트 마스크가 0이 된다는 것은 [0, b]와 [0, a - 1]가 같다는 것을 의미 즉 [0, 1] [0, 2] ... [0, n]의 비트 마스크를 각각 구해 그 빈도수를 조사하면(같은 게 몇 개씩 있는지를 조사) 비트 마스크가 0이 되는 부분 문자열이 몇 개 인지 알 수 있음. 이떄 그 빈도수는 누적해서 더해야 함. (같은 비트 마스크가 4번 나온다고 해서 부분 문자열이 4개인 것이 아님. 같은 비트 마스크 4개가 1, 2, 3, 4 이런 순서로 나올 텐데, 1과 2가 조합되었을 떄의 부분 문자열이 1개, 3과 조합되었을 떄는 2개 (3 - 1, 3 - 2), 4와 조합되었을 떄는 3개가 나옴. 따라서 1 + 2 + 3 처럼 누적 되어야 한다.)
비트 마스크에서 1이 딱 한 번 만 나오는 부분 문자열의 개수를 알아야 함 -> 1에서 순차적으로 구해나가는 각 마스크에 대해 딱 1비트만 차이나는(특정 알파벳의 위치의 비트. a ~ j ) 비트 마스크의 빈도수를 확인하여 더함.
